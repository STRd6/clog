// Generated by CoffeeScript 1.6.2
(function() {
  var BLANK_LINES, accumulateNode, analyzeClass, anonymousFunctions, calculateScore, churn, classFunctions, countNodes, exec, fs, getMethods, glob, merge, methods, nextNode, nodes, objectLiteralFunctions, readFile, score, scoreIfElse, scoreSwitch, variableFunctions,
    _this = this;

  exec = require('child_process').exec;

  nodes = require('coffee-script').nodes;

  fs = require('fs');

  glob = require('glob');

  BLANK_LINES = /^\s*$[\n\r]{1,}/gm;

  merge = function(object, properties) {
    var key, val;

    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  readFile = function(path) {
    return fs.readFileSync(path, 'utf8').replace(BLANK_LINES, '');
  };

  objectLiteralFunctions = function(exp) {
    var methods, objects, _ref, _ref1, _ref2;

    methods = {};
    if ((objects = ((_ref = exp.value) != null ? (_ref1 = _ref.base) != null ? _ref1.objects : void 0 : void 0) || ((_ref2 = exp.base) != null ? _ref2.objects : void 0))) {
      objects.forEach(function(obj, index) {
        var end, methodLength, methodName, start;

        if (obj.value.params != null) {
          methodName = obj.variable.base.value;
          end = obj.locationData.last_line;
          start = obj.locationData.first_line;
          if (index === objects.length - 1) {
            methodLength = end - start;
          } else {
            methodLength = end - start - 1;
          }
          return methods[methodName] = methodLength;
        }
      });
    }
    return methods;
  };

  anonymousFunctions = function(exp) {
    var end, output, start;

    output = {};
    if (exp.params != null) {
      start = exp.locationData.first_line;
      end = exp.locationData.last_line;
      output["anonymous"] || (output["anonymous"] = []);
      output["anonymous"].push(end - start);
    }
    return output;
  };

  variableFunctions = function(exp) {
    var end, end_col, length, output, start, start_col, _ref;

    output = {};
    if (((_ref = exp.value) != null ? _ref.params : void 0) != null) {
      start = exp.value.locationData.first_line;
      end = exp.value.locationData.last_line;
      end_col = exp.value.locationData.last_column;
      start_col = exp.value.locationData.first_column;
      length = end - start;
      if (end_col < start_col) {
        length -= 1;
      }
      output[exp.variable.base.value] = length;
    }
    return output;
  };

  classFunctions = function(exp, parentNode) {
    var output, _ref;

    output = {};
    if ((_ref = exp.body) != null ? _ref.classBody : void 0) {
      output = analyzeClass(parentNode);
    }
    return output;
  };

  analyzeClass = function(node) {
    return objectLiteralFunctions(node.expressions[0].body.expressions[0]);
  };

  nextNode = function(exp, output) {
    var body, _ref;

    if (body = (_ref = exp.value) != null ? _ref.body : void 0) {
      return getMethods(body, output);
    }
  };

  /*
  metric: complexity score
  
  A score that weights programming
  constructs according to difficulty
  to maintain. Files with a high
  score should be refactored to
  be more maintainable
  */


  scoreIfElse = function(exp, nestedFactor, score) {
    var expressions, _ref, _ref1;

    if (nestedFactor == null) {
      nestedFactor = 1;
    }
    if (score == null) {
      score = 0;
    }
    if (exp.condition) {
      score += nestedFactor;
    }
    if (exp.elseBody) {
      score += nestedFactor;
    }
    if ((expressions = ((_ref = exp.body) != null ? _ref.expressions : void 0) || ((_ref1 = exp.elseBody) != null ? _ref1.expressions : void 0))) {
      expressions.forEach(function(exp) {
        nestedFactor = nestedFactor * 2;
        return score = scoreIfElse(exp, nestedFactor, score);
      });
    }
    return score;
  };

  scoreSwitch = function(exp, nestedFactor, score) {
    var cases;

    if (nestedFactor == null) {
      nestedFactor = 1;
    }
    if (score == null) {
      score = 0;
    }
    if (cases = exp.cases) {
      cases.forEach(function(c) {
        return score += 1;
      });
    }
    if (exp.otherwise) {
      score += 1;
    }
    return score;
  };

  calculateScore = function(node, score) {
    if (score == null) {
      score = 0;
    }
    node.expressions.forEach(function(exp) {
      score += scoreIfElse(exp);
      return score += scoreSwitch(exp);
    });
    return score;
  };

  score = function(filePath) {
    var file;

    file = readFile(filePath);
    return calculateScore(nodes(file));
  };

  /*
  metric: method length
  
  Name and length of each method.
  Methods with bodies longer than
  a specified value should be refactored
  */


  getMethods = function(node, output, nested) {
    if (output == null) {
      output = {};
    }
    if (nested == null) {
      nested = false;
    }
    node.expressions.forEach(function(exp) {
      merge(output, anonymousFunctions(exp));
      merge(output, variableFunctions(exp));
      merge(output, objectLiteralFunctions(exp));
      merge(output, classFunctions(exp, node));
      return nextNode(exp, output, nested);
    });
    return output;
  };

  methods = function(filePath) {
    var file;

    file = readFile(filePath);
    return getMethods(nodes(file));
  };

  /*
  metric: churn
  
  Indicates how many times a
  file has been changed. The more
  it has been changed, the better a
  candidate it is for refactoring since
  it probably does too many things
  */


  churn = function(filePath, cb) {
    return exec("git whatchanged " + filePath + " | grep 'commit' | wc -l", cb);
  };

  /*
  metric: count nodes
  
  Simple proxy for complexity. The higher
  the number of nodes a file has, the more
  complex it is
  */


  accumulateNode = function(node, totalNodes) {
    if (totalNodes == null) {
      totalNodes = 0;
    }
    node.expressions.forEach(function(n) {
      var body, _ref;

      totalNodes += 1;
      if (body = (_ref = n.value) != null ? _ref.body : void 0) {
        return accumulateNode(body, totalNodes);
      }
    });
    return totalNodes;
  };

  countNodes = function(filePath) {
    var file;

    file = readFile(filePath);
    return accumulateNode(nodes(file));
  };

  exports.clog = {
    churn: churn,
    countNodes: countNodes,
    methods: methods,
    score: score
  };

}).call(this);
